---
title: "Projeto de Medição"
author: "Aline Costa - Rafaelle Amorim - Órion Darshan Winter"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}
library(dplyr, warn.conflicts = FALSE)
library(ggplot2)
library(lubridate)
library(resample)

theme_set(theme_bw())
```

###Descrição do sistema  
  O sistema que decidimos avaliar é um serviço de predição utilizado pelo aplicativo Melhor Busão, aplicativo criado com o intuito de melhorar a experiência dos usuários de transporte público, inicialmente da cidade de Campina Grande - PB e Curitiba - PR.  
  O serviço ter como função principal prever a quantidade de passageiros e a duração de uma viagem de ônibus de um dado usuário.    Para realizar tal função, o serviço pede os dados da rota do ônibus, parada de início, data e hora da viagem e, através de técnicas de aprendizado de máquina, prevê a quantidade de passageiros e a duração da viagem passada.  
  Este serviço está hospedado em um máquina virtual no Laboratório de Sistemas Distribuídos (LSD), localizado na Universidade Federal de Campina Grande (UFCG).
  
###Objetivo  
  Decidimos avaliar o sistema quanto ao critério de Escalabilidade, pois é um aspecto de extrema importância no desenvolvimento de sistemas em geral. Em especial para a nossa aplicação, que deverá ser implantada em breve e espera-se que ela consiga trabalhar normalmente mesmo com uma demanda crescente de usuários.  
  Para isso, nossa avaliação terá como principal atividade o aumento da quantidade de requisições a que o sistema é submetido e iremos analisar como se comporta o tempo de respostas às requisições diante desse aumento.  
  Além da quantidade de requisições, iremos avaliar o impacto da variação da mudança no horário no qual as requisições serão feitas (10hrs e 22hrs, aproximadamente) e se o número de instâncias rodando o serviço pode influenciar na escalabilidade do sistema. 

###Especificação de Ambiente
	Para realizar as medições, vamos utilizar uma máquina de 64 bits, com processador Intel® CoreT i5-3570 CPU @ 3.40GHz × 4, memória de 12GB, rodando em cima do sistema operacional Ubuntu 16.04. A rede que será utilizada na medição tem velocidade declarada de 10 Gbps.

###Definição de Métricas
	Para realizarmos nossa avaliação, vamos utilizar as seguintes variáveis de resposta (métricas) :
* Tempo de Resposta de Requisição:  
  Para isso vamos usar um medidor de timestamp e calcular o tempo discorrido entre o envio das requisições e o recebimento das respostas enviadas pelo servidor. Para eliminar fatores secundários que possam influenciar na nossa análise, iremos realizar X repetições para cada bloco de variáveis e as requisições realizadas serão sempre do tipo GET. 
* Tempo de Resposta da Rede:  
  A medição será realizada de forma ativa, já que as requisições serão injetadas no sistema para a verificação do seu comportamento quando ocorrer variação desse número.

###Definição de Fatores e Níveis

	As métricas tempo de resposta de requisição e tempo de resposta da rede serão utilizados para avaliar a escalabilidade do sistema, quando existe variação no número de instâncias rodando, número de requisições e horário das requisições.  
  Os níveis de cada fator serão definidos de acordo com os seguintes valores:
  
* Número de Instâncias:  
  1 instância  
  2 instâncias
* Números de Requisições:  
  10/min  
  40/min
* Horário das Requisições:  
  10h - 11h  
  22h - 23h
  
  A combinação dos fatores e seus níveis será executada como mostra a tabela abaixo. Realizaremos 3 medições de cada tipo nos horários mencionados durante 3 dias alternados. 
  
  Medição | Instâncias | Requisições/min | Horário
  --------|------------|-----------------|--------
     1    |     1      |        10       |  10h~11h
     2    |     1      |        10       |  22h~23h
     3    |     1      |        40       |  10h~11h
     4    |     1      |        40       |  22h~23h
     5    |     2      |        10       |  10h~11h
     6    |     2      |        10       |  22h~23h
     7    |     2      |        40       |  10h~11h
     8    |     2      |        40       |  22h~23h

###Experimentos

	As requisições realizadas, foram geradas ##(EXPLICAR O SCRIPT)## .
Durante a primeira execução do experimento, os níveis do fator "Números de Requisições" foram 100/s e 1000/s mas pudemos perceber que devido a quantidade de requisições sendo realizadas, o serviço não conseguiu responder à todas elas ##(EXPLICAR MELHOR?)##, para que fosse possível obter resultados e analisá-los, foram avaliados alguns níveis, até obtermos os valores de 10/min e 40/min. 

-----------

###Resultados

```{r, message=FALSE, warning=FALSE, echo=FALSE}
output <- read.csv("output.csv",  encoding="UTF-8")

data <- output %>% 
  mutate(
    datetime = as.POSIXct(start_timestamp / 1000, origin="1970-01-01"),
    days = day(datetime),
    months = month(datetime),
    hours = hour(datetime),
    minutes = minute(datetime),
    seconds = second(datetime)
  ) %>%
  mutate(
    hours = ifelse(hours <= 14, 10, 22),
    n_instances = ifelse(days == 27, 1, 2)
  )
```

Inicialmente Ã© verificado o tempo de resposta, sem levar em consideraÃ§Ã£o os fatores, e o quanto ele varia:

```{r}
ggplot(data, aes("Time difference", time_diff)) +
  geom_boxplot()

summary(data$time_diff)
sd(data$time_diff)
```

Como Ã© possÃ­vel ver acima, o tempo de resposta varia bastante, onde sua mÃ©dia Ã© de 23,2 segundos, mediana de 20,1 e desvio padrÃ£o de 13,3. Os valores do primeiro e terceiro quartil sÃ£o de 10,5 e 38,7 segundos, os quais se aproxÃ­mam bastante do nÃºmero de requisiÃ§Ãµes por minuto utilizados na mediÃ§Ã£o (10 e 40).

A segui Ã© possÃ­vel ver a distribuiÃ§Ã£o destes dados:

```{r}
ggplot(data, aes(time_diff)) +
  geom_histogram(bins = 15)
```

Ã‰ possÃ­vel ver que a distribuiÃ§Ã£o Ã© multimodal, o que pode indicar que os fatores influenciam no tempo de resposta.

Abaixo vamos verificar como cada conjunto de fatores se comporta, onde cada um serÃ¡ representado cada um nÃºmero:

```{r}
data <- data %>% 
  mutate(
    group = ifelse(n_instances == 1, 
                   ifelse(n_iterations == 10, 
                          ifelse(hours == 10, 1, 2),
                          ifelse(hours == 10, 3, 4)
                          ),
                   ifelse(n_iterations == 10, 
                          ifelse(hours == 10, 5, 6),
                          ifelse(hours == 10, 7, 8)
                          )
                   )
  )
```

```{r}
data %>% select(n_instances, n_iterations, hours, group) %>% distinct() %>% arrange(group)
```

A seguir, serÃ¡ verificado se existe relaÃ§Ã£o entre os fatores escolhidos e o tempo de resposta:

```{r}
ggplot(data, aes(as.factor(group), time_diff)) +
  geom_boxplot()
```

Ã‰ possÃ­vel verificar que a hora nÃ£o influencia no tempo de resposta, visto que os grupos 1 e 2 tem horas diferentes, mas variam os demais fatores, o que tambÃ©m ocorre com os grupos 3 e 4, 5 e 6, 7 e 8. 

Ã‰ possÃ­vel ver que o nÃºmero de requisiÃ§Ãµes por minuto Ã© um fator que causa bastante impacto no tempo de resposta, visto que conservando os demais fatores e variando o nÃºmero de requisiÃ§Ãµes, o tempo de resposta diferencia bastante, como podemos ver nos grupos 1 e 3, 2 e 4, 5 e 7, 6 e 8. 

Ã‰ possÃ­vel identificar tambÃ©m que o nÃºmero de instancias utilizadas na mediÃ§Ã£o influencia bastante o tempo de resposta, visto que fixando os demais fatores e mudando apenas o nÃºmero de instÃ¢ncias, o tempo de resposta varia bastante, como pode ser verificado nos grupos 1 e 5, 2 e 6, 3 e 7, 4 e 8.


```{r}
#Summary de cada grupo
#tapply(data$time_diff,data$group,summary) 
```

___
Vamos verificar como é a distribuição do tempo de resposta, avaliando o número de instâncias, número de requisições e o horário do experimento.

```{r}
ggplot(data, aes(x=factor(n_iterations), y=time_diff,fill=factor(hours))) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_grid(~n_instances) +
  labs(y="Tempo de requisição", fill="Horário do experimento", x= "Número de requisições por minuto")
```


```{r}
ggplot(data, aes(time_diff, fill=factor(hours))) +
  geom_histogram(bins = 10, position = "dodge")+ facet_grid(n_iterations~n_instances)   +
  labs(x="Tempo de resposta de requisição", fill="Hora do experimento")
```

-- Mostrar o intervalo de confiança do tempo de resposta para cada grupo


```{r}
experiment = sample_n(data, 500, replace = TRUE)

b = experiment %>%
  group_by(group) %>%
  bootstrap(mean(time_diff), R = 500)

mean.boot= bootstrap(experiment, mean(time_diff), R = 500)
mean.time = CI.bca(mean.boot, probs = c(.025, .975))
mean.time

median.boot = bootstrap(experiment, median(time_diff))
median.time = CI.percentile(median.boot, probs = c(.025, .975))
median.time 

df = data.frame(rbind(mean.time, 
                      median.time))

df$medida = row.names(df)

df %>% 
  
  ggplot(aes(x = medida, ymin = X2.5., ymax = X97.5.)) + 
  geom_errorbar(width = .2)

```


Agora iremos analisar o tempo de resposta das requisição levando em conta a "posição" da requisição (a primeira requisição, segunda, terceira..) 

```{r}
# Mostrar que primeiras requisiÃ§Ãµes sÃ£o mais rÃ¡pidas que as demais (que dÃ¡ para pegar pelo curr_iteration)

data.first.iterations <- data %>%
  group_by(curr_iteration)

ggplot(data.first.iterations,aes(x=curr_iteration, y=time_diff)) +
  geom_bar(stat = "identity")+
  facet_grid(~n_instances)

```


-- Mais anÃ¡lises que queiram

--------

###Considerações Finais 

#Precisa colocar essa parte?


