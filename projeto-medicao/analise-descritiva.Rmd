---
title: "Projeto de Medição"
author: "Aline Costa - Rafaelle Amorim - Órion Darshan Winter"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}
library(dplyr, warn.conflicts = FALSE)
library(ggplot2)
library(lubridate)
library(resample)
library(gtable)
library(grid)


theme_set(theme_bw())
```

```{r}

label.geral.top <- function(distribuicao) {
  
  ## Para adicionar o label geral
  distribuicao.grob = ggplotGrob(distribuicao)
  #  New strip at the top
  distribuicao.grob <- gtable_add_rows(distribuicao.grob, distribuicao.grob$height[6], pos = 5)  # New row added below row 5
  # Check the layout
  gtable_show_layout(distribuicao.grob)   # New strip goes into row 6 
                        # New strip spans columns 4 to 8
  distribuicao.grob <- gtable_add_grob(distribuicao.grob, 
    list(rectGrob(gp = gpar(col = NA, fill = "gray85", size = .5)),
       textGrob("Número de Instâncias")), t=6, l=4, b=6, r=8, name = c("a", "b"))

  # Add small gap between strips - below row 6
  distribuicao.grob <- gtable_add_rows(distribuicao.grob, unit(2/10, "line"), 6)
  
  # Draw it
  ##grid.draw(distribuicao.grob)
  
  return(distribuicao.grob)
}

label.geral.top.e.right <- function(distribuicao) {
  
    ## Para adicionar o label geral
  distribuicao.grob = ggplotGrob(distribuicao)
  #  New strip at the top
  distribuicao.grob <- gtable_add_rows(distribuicao.grob, distribuicao.grob$height[6], pos = 5)  # New row added below row 5
  distribuicao.grob <- gtable_add_cols(distribuicao.grob, distribuicao.grob$widths[7], pos = 7)  # New column added to the right of column 5

  # Check the layout
  gtable_show_layout(distribuicao.grob)   # New strip goes into row 6 
                        # New strip spans columns 4 to 8
  distribuicao.grob <- gtable_add_grob(distribuicao.grob, 
    list(rectGrob(gp = gpar(col = NA, fill = "gray85", size = .5)),
       textGrob("Número de Instâncias")), t=6, l=4, b=6, r=8, name = c("a", "b"))
  
  distribuicao.grob<- gtable_add_grob(distribuicao.grob, 
    list(rectGrob(gp = gpar(col = NA, fill = "gray85", size = .5)),
       textGrob("Nº de Requisições / min", rot = -90)), 
    t=5, l=8, b=10, r=9, name = c("a", "b"))

  # Add small gap between strips - below row 6
  distribuicao.grob <- gtable_add_rows(distribuicao.grob, unit(2/10, "line"), 6)
    distribuicao.grob <- gtable_add_cols(distribuicao.grob, unit(2/10, "line"), 7)

  return (distribuicao.grob)
}
  
  

label.geral.right <- function(distribuicao, nome){
  
  distribuicao.grob <- ggplotGrob(distribuicao)

  #  New strip to the right
  distribuicao.grob <- gtable_add_cols(distribuicao.grob, distribuicao.grob$widths[7], pos = 7)  # New column added to the right of column 5

  # Check the layout
  gtable_show_layout(distribuicao.grob)   # New strip goes into column 6 
                        # New strip spans rows 6 to 10
  distribuicao.grob<- gtable_add_grob(distribuicao.grob, 
    list(rectGrob(gp = gpar(col = NA, fill = "gray85", size = .5)),
       textGrob(nome, rot = -90)), 
    t=5, l=8, b=10, r=9, name = c("a", "b"))

  # Add small gap between strips - to the right of column 5
  distribuicao.grob <- gtable_add_cols(distribuicao.grob, unit(2/10, "line"), 7)

  # Draw it
  ##grid.draw(distribuicao.grob)
  return (distribuicao.grob)
}

```


###Descrição do sistema  
  O sistema que decidimos avaliar é um serviço de predição utilizado pelo aplicativo Melhor Busão, aplicativo criado com o intuito de melhorar a experiência dos usuários de transporte público, inicialmente da cidade de Campina Grande - PB e Curitiba - PR.  
  O serviço ter como função principal prever a quantidade de passageiros e a duração de uma viagem de ônibus de um dado usuário.    Para realizar tal função, o serviço pede os dados da rota do ônibus, parada de início, data e hora da viagem e, através de técnicas de aprendizado de máquina, prevê a quantidade de passageiros e a duração da viagem passada.  
  Este serviço está hospedado em um máquina virtual no Laboratório de Sistemas Distribuídos (LSD), localizado na Universidade Federal de Campina Grande (UFCG).
  
###Objetivo  
  Decidimos avaliar o sistema quanto ao critério de Escalabilidade, pois é um aspecto de extrema importância no desenvolvimento de sistemas em geral. Em especial para a nossa aplicação, que deverá ser implantada em breve e espera-se que ela consiga trabalhar normalmente mesmo com uma demanda crescente de usuários.  
  Para isso, nossa avaliação terá como principal atividade o aumento da quantidade de requisições a que o sistema é submetido e iremos analisar como se comporta o tempo de respostas às requisições diante desse aumento.  
  Além da quantidade de requisições, iremos avaliar o impacto da variação da mudança no horário no qual as requisições serão feitas (10hrs e 22hrs, aproximadamente) e se o número de instâncias rodando o serviço pode influenciar na escalabilidade do sistema. 

###Especificação de Ambiente
	Para realizar as medições, vamos utilizar uma máquina de 64 bits, com processador Intel® CoreT i5-3570 CPU @ 3.40GHz × 4, memória de 12GB, rodando em cima do sistema operacional Ubuntu 16.04. A rede que será utilizada na medição tem velocidade declarada de 10 Gbps.

###Definição de Métricas
	Para realizarmos nossa avaliação, vamos utilizar as seguintes variáveis de resposta (métricas) :
* Tempo de Resposta de Requisição:  
  Para isso vamos usar um medidor de timestamp e calcular o tempo discorrido entre o envio das requisições e o recebimento das respostas enviadas pelo servidor. Para eliminar fatores secundários que possam influenciar na nossa análise, iremos realizar X repetições para cada bloco de variáveis e as requisições realizadas serão sempre do tipo GET. 
* Tempo de Resposta da Rede:  
  A medição será realizada de forma ativa, já que as requisições serão injetadas no sistema para a verificação do seu comportamento quando ocorrer variação desse número.

###Definição de Fatores e Níveis

	As métricas tempo de resposta de requisição e tempo de resposta da rede serão utilizados para avaliar a escalabilidade do sistema, quando existe variação no número de instâncias rodando, número de requisições e horário das requisições.  
  Os níveis de cada fator serão definidos de acordo com os seguintes valores:
  
* Número de Instâncias:  
  1 instância  
  2 instâncias
* Números de Requisições:  
  10/min  
  40/min
* Horário das Requisições:  
  10h - 11h  
  22h - 23h
  
  A combinação dos fatores e seus níveis será executada como mostra a tabela abaixo. Realizaremos 3 medições de cada tipo nos horários mencionados durante 3 dias alternados. 
  
  Medição | Instâncias | Requisições/min | Horário
  --------|------------|-----------------|--------
     1    |     1      |        10       |  10h~11h
     2    |     1      |        10       |  22h~23h
     3    |     1      |        40       |  10h~11h
     4    |     1      |        40       |  22h~23h
     5    |     2      |        10       |  10h~11h
     6    |     2      |        10       |  22h~23h
     7    |     2      |        40       |  10h~11h
     8    |     2      |        40       |  22h~23h

###Experimentos

	As requisições realizadas, foram geradas ##(EXPLICAR O SCRIPT)## .
Durante a primeira execução do experimento, os níveis do fator "Números de Requisições" foram 100/s e 1000/s mas pudemos perceber que devido a quantidade de requisições sendo realizadas, o serviço não conseguiu responder à todas elas ##(EXPLICAR MELHOR?)##, para que fosse possível obter resultados e analisá-los, foram avaliados alguns níveis, até obtermos os valores de 10/min e 40/min. 

-----------

###Resultados

```{r, message=FALSE, warning=FALSE, echo=FALSE}
output <- read.csv("output.csv",  encoding="UTF-8")

data <- output %>% 
  mutate(
    datetime = as.POSIXct(start_timestamp / 1000, origin="1970-01-01"),
    days = day(datetime),
    months = month(datetime),
    hours = hour(datetime),
    minutes = minute(datetime),
    seconds = second(datetime)
  ) %>%
  mutate(
    hours = ifelse(hours <= 14, 10, 22),
    n_instances = ifelse(days == 27, 1, 2)
  )
```

Inicialmente é verificado o tempo de resposta, sem levar em consideração os fatores, e o quanto ele varia:

```{r}
ggplot(data, aes("Time difference", time_diff)) +
  geom_boxplot()+
  labs(y="Tempo de Resposta (ms)")

summary(data$time_diff)
sd(data$time_diff)
```

Como é possível ver acima, o tempo de resposta varia bastante, onde sua média é de 23,2 segundos, mediana de 20,1 segundos e desvio padrão de 13,3 segundos. Os valores do primeiro e terceiro quartil são de 10,5 e 38,7 segundos, os quais se aproxímam bastante do número de requisições por minuto utilizados na medição (10 e 40).

--------------

A seguir é possível ver a distribuição destes dados:

```{r}
ggplot(data, aes(time_diff)) +
  geom_histogram(bins = 15) +
  labs(x = "Tempo de resposta") +
  ggtitle("Histograma de distribuição dos dados")
```

É possível ver que a distribuição é multimodal, o que pode indicar que os fatores influenciam no tempo de resposta.

-----------

Abaixo vamos verificar como cada conjunto de fatores se comporta, onde cada um será representado por cada número:

```{r}
data <- data %>% 
  mutate(
    group = ifelse(n_instances == 1, 
                   ifelse(n_iterations == 10, 
                          ifelse(hours == 10, 1, 2),
                          ifelse(hours == 10, 3, 4)
                          ),
                   ifelse(n_iterations == 10, 
                          ifelse(hours == 10, 5, 6),
                          ifelse(hours == 10, 7, 8)
                          )
                   )
  )
```

```{r}
data.group = data %>% select(n_instances, n_iterations, hours, group) %>% distinct() %>% arrange(group)
colnames(data.group) <- c("Nº de Instâncias", "Nº de Requisições / min", "Horário", "Grupo")
data.group
```

A seguir, vamos verificar como é o comportamento de cada conjunto de fatores que foram definidos acima, e se existe relação entre os fatores escolhidos e o tempo de resposta:

-------------------

```{r}
ggplot(data, aes(as.factor(group), time_diff)) +
  geom_boxplot() +
  labs(x="Grupos", y="Tempo de Resposta")+
  ggtitle("Gráfico de relação entre fatores e tempo de resposta")	

#Summary de cada grupo
tapply(data$time_diff,data$group,summary)
tapply(data$time_diff,data$group,sd)


```


É possível verificar que a hora não influencia no tempo de resposta, visto que os grupos 1 e 2 tem horas diferentes, mas variam os demais fatores, o que também ocorre com os grupos 3 e 4, 5 e 6, 7 e 8. 

É possível ver que o número de requisições por minuto é um fator que causa bastante impacto no tempo de resposta, visto que conservando os demais fatores e variando o número de requisições, o tempo de resposta diferencia bastante, como podemos ver nos grupos 1 e 3, 2 e 4, 5 e 7, 6 e 8. 

É possível identificar também que o número de instâncias utilizadas na medição influencia bastante o tempo de resposta, visto que fixando os demais fatores e mudando apenas o número de instâncias, o tempo de resposta varia bastante, como pode ser verificado nos grupos 1 e 5, 2 e 6, 3 e 7, 4 e 8.

-----

Vamos verificar como é a distribuição do tempo de resposta, avaliando o número de instâncias, número de requisições e o horário do experimento.

```{r}
distribuicao.num.instancias = ggplot(data, aes(x=factor(n_iterations), y=time_diff,fill=factor(hours))) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_grid(~n_instances) +
  labs(y="Tempo de Resposta", fill="Horário do Experimento", x= "Número de requisições por minuto")

## Para adicionar o label geral
grid.draw(label.geral.top(distribuicao.num.instancias))


```


```{r}
distribuicao.geral = ggplot(data, aes(time_diff, fill=factor(hours))) +
  geom_histogram(bins = 10, position = "dodge")+ facet_grid(n_iterations~n_instances)   +
  labs(x="Tempo de Resposta", fill="Horário do experimento")

## Para adicionar o label geral
#label.top = label.geral.top(distribuicao.geral)

grid.draw(label.geral.top.e.right(distribuicao.geral))


```

-- Mostrar o intervalo de confiança do tempo de resposta para cada grupo


```{r}
experiment = sample_n(data, 500, replace = TRUE)

b = experiment %>%
  group_by(group) %>%
  bootstrap(mean(time_diff), R = 500)

mean.boot= bootstrap(experiment, mean(time_diff), R = 500)
mean.time = CI.bca(mean.boot, probs = c(.025, .975))
mean.time

median.boot = bootstrap(experiment, median(time_diff))
median.time = CI.percentile(median.boot, probs = c(.025, .975))
median.time 

df = data.frame(rbind(mean.time, 
                      median.time))

df$medida = row.names(df)

df %>% ggplot(aes(x = medida, ymin = X2.5., ymax = X97.5.)) + 
  geom_errorbar(width = .2)

```


Agora iremos analisar o tempo de resposta das requisição levando em conta a "posição" da requisição (a primeira requisição, segunda, terceira..) 

```{r}
# Mostrar que primeiras requisiÃ§Ãµes sÃ£o mais rÃ¡pidas que as demais (que dÃ¡ para pegar pelo curr_iteration)

data.first.iterations <- data %>%
  group_by(curr_iteration)

ggplot(data.first.iterations,aes(x=curr_iteration, y=time_diff)) +
  geom_bar(stat = "identity")+
  facet_grid(~n_instances)

```


-- Mais anÃ¡lises que queiram

--------

###Considerações Finais 

#Precisa colocar essa parte?


