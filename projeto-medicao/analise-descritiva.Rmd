---
title: "Projeto de Medi√ß√£o"
author: "Aline Costa - Rafaelle Amorim - √ìrion Winter de Lima"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}
library(dplyr, warn.conflicts = FALSE)
library(ggplot2)
library(lubridate)
library(resample)
library(gtable)
library(grid)


theme_set(theme_bw())
```

```{r}

label.geral.top <- function(distribuicao, nome.label) {
  
  ## Para adicionar o label geral
  distribuicao.grob = ggplotGrob(distribuicao)
  #  New strip at the top
  distribuicao.grob <- gtable_add_rows(distribuicao.grob, distribuicao.grob$height[6], pos = 5)  # New row added below row 5
  # Check the layout
  gtable_show_layout(distribuicao.grob)   # New strip goes into row 6 
                        # New strip spans columns 4 to 8
  distribuicao.grob <- gtable_add_grob(distribuicao.grob, 
    list(rectGrob(gp = gpar(col = NA, fill = "gray85", size = .5)),
       textGrob(nome.label)), t=6, l=4, b=6, r=8, name = c("a", "b"))

  # Add small gap between strips - below row 6
  distribuicao.grob <- gtable_add_rows(distribuicao.grob, unit(2/10, "line"), 6)
  
  # Draw it
  ##grid.draw(distribuicao.grob)
  
  return(distribuicao.grob)
}

label.geral.top.e.right <- function(distribuicao, nome.label.top, nome.label.right) {
  
    ## Para adicionar o label geral
  distribuicao.grob = ggplotGrob(distribuicao)
  #  New strip at the top
  distribuicao.grob <- gtable_add_rows(distribuicao.grob, distribuicao.grob$height[6], pos = 5)  # New row added below row 5
  distribuicao.grob <- gtable_add_cols(distribuicao.grob, distribuicao.grob$widths[7], pos = 7)  # New column added to the right of column 5

  # Check the layout
  gtable_show_layout(distribuicao.grob)   # New strip goes into row 6 
                        # New strip spans columns 4 to 8
  distribuicao.grob <- gtable_add_grob(distribuicao.grob, 
    list(rectGrob(gp = gpar(col = NA, fill = "gray85", size = .5)),
       textGrob(nome.label.top)), t=6, l=4, b=6, r=8, name = c("a", "b"))

  distribuicao.grob<- gtable_add_grob(distribuicao.grob, 
    list(rectGrob(gp = gpar(col = NA, fill = "gray85", size = .5)),
       textGrob("N¬∫ de Requisi√ß√µes / min", rot = -90)), 
    t=5, l=8, b=10, r=9, name = c("a", "b"))

  # Add small gap between strips - below row 6
  distribuicao.grob <- gtable_add_rows(distribuicao.grob, unit(2/10, "line"), 6)
    distribuicao.grob <- gtable_add_cols(distribuicao.grob, unit(2/10, "line"), 7)

  return (distribuicao.grob)
}
  
  

label.geral.right <- function(distribuicao, nome){
  
  distribuicao.grob <- ggplotGrob(distribuicao)

  #  New strip to the right
  distribuicao.grob <- gtable_add_cols(distribuicao.grob, distribuicao.grob$widths[7], pos = 7)  # New column added to the right of column 5

  # Check the layout
  gtable_show_layout(distribuicao.grob)   # New strip goes into column 6 
                        # New strip spans rows 6 to 10
  distribuicao.grob<- gtable_add_grob(distribuicao.grob, 
    list(rectGrob(gp = gpar(col = NA, fill = "gray85", size = .5)),
       textGrob(nome, rot = -90)), 
    t=5, l=8, b=10, r=9, name = c("a", "b"))

  # Add small gap between strips - to the right of column 5
  distribuicao.grob <- gtable_add_cols(distribuicao.grob, unit(2/10, "line"), 7)

  # Draw it
  ##grid.draw(distribuicao.grob)
  return (distribuicao.grob)
}

```


###Descri√ß√£o do sistema  
  O sistema que decidimos avaliar √© um servi√ßo de predi√ß√£o utilizado pelo aplicativo Melhor Bus√£o, aplicativo criado com o intuito de melhorar a experi√™ncia dos usu√°rios de transporte p√∫blico, inicialmente da cidade de Campina Grande - PB e Curitiba - PR.  
  O servi√ßo ter como fun√ß√£o principal prever a quantidade de passageiros e a dura√ß√£o de uma viagem de √¥nibus de um dado usu√°rio.    Para realizar tal fun√ß√£o, o servi√ßo pede os dados da rota do √¥nibus, parada de in√≠cio, data e hora da viagem e, atrav√©s de t√©cnicas de aprendizado de m√°quina, prev√™ a quantidade de passageiros e a dura√ß√£o da viagem passada.  
  Este servi√ßo est√° hospedado em um m√°quina virtual no Laborat√≥rio de Sistemas Distribu√≠dos (LSD), localizado na Universidade Federal de Campina Grande (UFCG).
  
###Objetivo  
  Decidimos avaliar o sistema quanto ao crit√©rio de Escalabilidade, pois √© um aspecto de extrema import√¢ncia no desenvolvimento de sistemas em geral. Em especial para a nossa aplica√ß√£o, que dever√° ser implantada em breve e espera-se que ela consiga trabalhar normalmente mesmo com uma demanda crescente de usu√°rios.  
  Para isso, nossa avalia√ß√£o ter√° como principal atividade o aumento da quantidade de requisi√ß√µes a que o sistema √© submetido e iremos analisar como se comporta o tempo de respostas √†s requisi√ß√µes diante desse aumento.  
  Al√©m da quantidade de requisi√ß√µes, iremos avaliar o impacto da varia√ß√£o da mudan√ßa no hor√°rio no qual as requisi√ß√µes ser√£o feitas (10hrs e 22hrs, aproximadamente) e se o n√∫mero de inst√¢ncias rodando o servi√ßo pode influenciar na escalabilidade do sistema. 

###Especifica√ß√£o de Ambiente
	Para realizar as medi√ß√µes, vamos utilizar uma m√°quina de 64 bits, com processador Intel¬Æ CoreT i5-3570 CPU @ 3.40GHz √ó 4, mem√≥ria de 12GB, rodando em cima do sistema operacional Ubuntu 16.04. A rede que ser√° utilizada na medi√ß√£o tem velocidade declarada de 10 Gbps.

###Defini√ß√£o de M√©tricas
	Para realizarmos nossa avalia√ß√£o, vamos utilizar as seguintes vari√°veis de resposta (m√©tricas) :
* Tempo de Resposta de Requisi√ß√£o:  
  Para isso vamos usar um medidor de timestamp e calcular o tempo discorrido entre o envio das requisi√ß√µes e o recebimento das respostas enviadas pelo servidor. Para eliminar fatores secund√°rios que possam influenciar na nossa an√°lise, iremos realizar X repeti√ß√µes para cada bloco de vari√°veis e as requisi√ß√µes realizadas ser√£o sempre do tipo GET. 

###Defini√ß√£o de Fatores e N√≠veis

	As mÈtricas tempo de resposta de requisi√ß√£o e tempo de resposta da rede ser√£o utilizados para avaliar a escalabilidade do sistema, quando existe varia√ß√£o no n√∫mero de inst√¢ncias rodando, n√∫mero de requisi√ß√µes e hor√°rio das requisi√ß√µes.  
  Os nÌveis de cada fator ser√£o definidos de acordo com os seguintes valores:
  
1. N√∫mero de Inst√¢ncias: 
   * 1 inst√¢ncia  
   * 2 inst√¢ncias
2. N√∫meros de Requisi√ß√µes:  
   * 10/min  
   * 40/min
3. Hor√°rio das Requisi√ß√µes:  
   * 10h - 11h  
   * 22h - 23h
  
  A combina√ß√£o dos fatores e seus n√≠veis ser√° executada como mostra a tabela abaixo. Realizaremos 3 medi√ß√µes de cada tipo nos hor√°rios mencionados durante 3 dias alternados. 
  
  Medi√ß√£o | Inst√¢ncias | Requisi√ß√µes/min | Hor√°rio
  --------|------------|-----------------|--------
     1    |     1      |        10       |  10h~11h
     2    |     1      |        10       |  22h~23h
     3    |     1      |        40       |  10h~11h
     4    |     1      |        40       |  22h~23h
     5    |     2      |        10       |  10h~11h
     6    |     2      |        10       |  22h~23h
     7    |     2      |        40       |  10h~11h
     8    |     2      |        40       |  22h~23h

###Experimentos

	As medi√ß√µes foram feitas a partir de um script nodeJS, o qual realizava a quantidade de requiisi√ß√µes especificadas (10/min e 40/min). Esse script rodou programaticamente atrav√©s do crontab, um programa nativo do Unix que executa comandos de forma agendada.
Inicialmente planejamos os n√≠veis do fator "N√∫meros de Requisi√ß√µes" como 100/s e 1000/s. No entanto, percebemos que o servi√ßo n√£o conseguiu responder √† todas elas, pois n√£o estava preparado para essa quantidade de requisi√ß√µes. Ent√£o, para que fosse poss√≠vel obter os resultados esperados e analis√°-los, testamos a resposta do sistema para outros n√≠veis do fator mencionado e estabelecemos que as quantidades adequadas ao nosso experimento seriam de 10/min e 40/min. 
A quantidade de inst√¢ncias foi modificada manualmente no sistema, de forma que nas primeiras 4 execu√ß√µes existisse 1 inst√¢ncia dispon√≠vel e nas 4 seguintes existissem 2 inst√¢ncias.

-----------

###Resultados

####Resultados gerais

```{r, message=FALSE, warning=FALSE, echo=FALSE}
output <- read.csv("output.csv",  encoding="UTF-8")

data <- output %>% 
  mutate(
    datetime = as.POSIXct(start_timestamp / 1000, origin="1970-01-01"),
    days = day(datetime),
    months = month(datetime),
    hours = hour(datetime),
    minutes = minute(datetime),
    seconds = second(datetime)
  ) %>%
  mutate(
    hours = ifelse(hours <= 14, 10, 22),
    n_instances = ifelse(days == 27, 1, 2)
  )
```

Abaixo √© mostrado o tempo de resposta do sistemas √†s requisi√ß√µes, sem levar em considera√ß√£o a varia√ß√£o dos fatores e seus n√≠veis.

```{r}
ggplot(data, aes("Time difference", time_diff)) +
  geom_boxplot()+
  labs(y="Tempo de Resposta (ms)")

summary(data$time_diff)
sd(data$time_diff)
```

Como √© poss√≠vel ver acima, o tempo de resposta varia bastante. Tendo como m√©dia 23,2 segundos, mediana 20,1 segundos e desvio padr√£o de 13,3 segundos. Os valores do primeiro e terceiro quartil s√£o de 10,5 e 38,7 segundos, os quais se aprox√≠mam bastante do n√∫mero de requisi√ß√µes por minuto utilizados na medi√ß√£o (10 e 40).

A seguir √© poss√≠vel ver a distribui√ß√£o destes dados em um Histograma:

```{r}
ggplot(data, aes(time_diff)) +
  geom_histogram(bins = 15) +
  labs(x = "Tempo de resposta") +
  ggtitle("Histograma de distribui√ß√£o dos dados")
```

<<<<<<< HEAD
Podemos observar que a distribuiÁ„o È multimodal, o que pode indicar que os fatores influenciam no tempo de resposta. Para uma maior representaÁ„o, decidimos utilizar o intervalo de confianÁa para a mÈdia e a mediana.



```{r}
experiment = sample_n(data, 1000, replace = TRUE)

b = experiment %>%
  bootstrap(mean(time_diff), R = 1000)

mean.boot= bootstrap(experiment, mean(time_diff), R = 1000)
mean.time = CI.bca(mean.boot, probs = c(.025, .975))
mean.time

median.boot = bootstrap(experiment, median(time_diff))
median.time = CI.percentile(median.boot, probs = c(.025, .975))
median.time 

df = data.frame(rbind(mean.time, 
                      median.time))

df$medida = row.names(df)
row.names(df)

df %>% ggplot(aes(x = medida, ymin = X2.5., ymax = X97.5.)) + 
  geom_errorbar(width = .2) + 
  ggtitle("Intervalo de confianÁa da estimativa das mÈdias e medianas do tempo de requisiÁ„o dos experimentos")

```
=======
Podemos observar que a distribui√ß√£o √© multimodal, o que pode indicar que os fatores influenciam no tempo de resposta. Para verificar essa hip√≥tese, analisamos os resultados a seguir.
>>>>>>> 3f67bd38cf16a048034fac6ead7c4ff8e5f81d08

-----------

####Resultados com varia√ß√£o de fatores

Abaixo listamos cada conjunto de fatores analisado. A numera√ß√£o √© utilizada para representar cada grupo de fatores no gr√°fico seguinte, onde analisamos o tempo de resposta, o comportamento geral, e se existe rela√ß√£o entre os fatores escolhidos.

```{r}
data <- data %>% 
  mutate(
    group = ifelse(n_instances == 1, 
                   ifelse(n_iterations == 10, 
                          ifelse(hours == 10, 1, 2),
                          ifelse(hours == 10, 3, 4)
                          ),
                   ifelse(n_iterations == 10, 
                          ifelse(hours == 10, 5, 6),
                          ifelse(hours == 10, 7, 8)
                          )
                   )
  )
```

```{r}
data.group = data %>% select(n_instances, n_iterations, hours, group) %>% distinct() %>% arrange(group)
colnames(data.group) <- c("N¬∫ de Inst√¢ncias", "N¬∫ de Requisi√ß√µes/min", "Hor√°rio", "Grupo")
data.group
```

-------------------

```{r}
ggplot(data, aes(as.factor(group), time_diff)) +
  geom_boxplot() +
  labs(x="Grupos", y="Tempo de Resposta")+
  ggtitle("Gr·fico de relaÁ„o entre fatores e tempo de resposta")	 +

#Summary de cada grupo
tapply(data$time_diff,data$group,summary)

```

Desvio padr„o para cada grupo:

```{r}
tapply(data$time_diff,data$group,sd)


```

√â poss√≠vel verificar que a hora n√£o influencia no tempo de resposta, visto que os grupos 1 e 2 tem horas diferentes, mas variam os demais fatores, o que tamb√©m ocorre com os grupos 3 e 4, 5 e 6, 7 e 8. 

√â poss√≠vel ver que o n√∫mero de requisi√ß√µes por minuto √© um fator que causa bastante impacto no tempo de resposta, visto que conservando os demais fatores e variando o n√∫mero de requisi√ß√µes, o tempo de resposta diferencia bastante, como podemos ver nos grupos 1 e 3, 2 e 4, 5 e 7, 6 e 8. 

√â poss√≠vel identificar tamb√©m que o n√∫mero de inst√¢ncias utilizadas na medi√ß√£o influencia bastante o tempo de resposta, visto que fixando os demais fatores e mudando apenas o n√∫mero de inst√¢ncias, o tempo de resposta varia bastante, como pode ser verificado nos grupos 1 e 5, 2 e 6, 3 e 7, 4 e 8.

-----

####Resultados e an√°lises adicionais

Como an√°lise adicional, vamos verificar como √© a distribui√ß√£o do tempo de resposta, avaliando o n√∫mero de inst√¢ncias, n√∫mero de requisi√ß√µes e o hor√°rio do experimento.

```{r}
distribuicao.num.instancias = ggplot(data, aes(x=factor(n_iterations), y=time_diff,fill=factor(hours))) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_grid(~n_instances) +
  labs(y="Tempo de Resposta", fill="Hor√°rio do Experimento", x= "N√∫mero de requisi√ß√µes por minuto")

## Para adicionar o label geral
grid.draw(label.geral.top(distribuicao.num.instancias, "N˙mero de Inst‚ncias"))


```


```{r}
distribuicao.geral = ggplot(data, aes(time_diff, fill=factor(hours))) +
  geom_histogram(bins = 10, position = "dodge")+ facet_grid(n_iterations~n_instances)   +
  labs(x="Tempo de Resposta", fill="Hor√°rio do experimento")

## Para adicionar o label geral
#label.top = label.geral.top(distribuicao.geral)

grid.draw(label.geral.top.e.right(distribuicao.geral,"N˙mero de Inst‚ncias","N∫ de RequisiÁıes / min"))


```

Como j√° observado anteriormente, o sistema apresenta um tempo de resposta m√©dio bem menor quando a quantidade de requisi√ß√µes por minuto √© de 10. E, especialmente para 40 requisi√ß√µes/minuto, o uso de 2 inst√¢ncias diminue consideravelmente o tempo de resposta.

<<<<<<< HEAD
-------------

####Intervalo de confianÁa para o tempo de resposta

#ESCOLHER ENTRE 1 E 2 

#(1)

```{r}

grupo.experimento.all = function(grupo){
  data.group = data %>% filter(group==grupo)
  
  experiment = sample_n(data.group, 500, replace = TRUE)

  b = experiment %>% bootstrap(mean(time_diff), R = 500)

  #Media
  mean.boot= bootstrap(experiment, mean(time_diff), R = 500)
  mean.time = CI.bca(mean.boot, c(.025, .975))

  #Mediana
  median.boot = bootstrap(experiment, median(time_diff))
  median.time = CI.percentile(median.boot, probs = c(.025, .975))

  df <- data.frame(matrix(NA, nrow = 1, ncol = 5))
  colnames(df) <- c("grupo","limite.inferior.media","limite.superior.media","limite.inferior.mediana","limite.superior.mediana")

  df[1,1] <- grupo
  df[1,2] <- mean.time[1,1]
  df[1,3] <- mean.time[1,2]
  df[1,4] <- median.time[1,1]
  df[1,5] <- median.time[1,2]
  
  

  return(df)
}


#Grupo 1
grupo.1.all = grupo.experimento.all(1)
grupo.2.all = grupo.experimento.all(2)
grupo.3.all = grupo.experimento.all(3)
grupo.4.all = grupo.experimento.all(4)
grupo.5.all = grupo.experimento.all(5)
grupo.6.all = grupo.experimento.all(6)
grupo.7.all = grupo.experimento.all(7)
grupo.8.all = grupo.experimento.all(8)


medidas.por.grupo.geral = data.frame(
  rbind(grupo.1.all,
        grupo.2.all,
        grupo.3.all,
        grupo.4.all,
        grupo.5.all,
        grupo.6.all,
        grupo.7.all,
        grupo.8.all))


medidas.por.grupo.geral %>% 
  ggplot(aes(x = grupo, ymin = limite.inferior.media, ymax = limite.superior.media)) + 
  geom_errorbar(width = .2) +
    ggtitle("Intervalo de confianÁa da estimativa das mÈdias do tempo de resposta \ncategorizados por grupo de experimento") +
  labs(x= "Grupos", "Tempo de resposta")


medidas.por.grupo.geral %>% 
  ggplot(aes(x = grupo, ymin = limite.inferior.mediana, ymax = limite.superior.mediana)) + 
  geom_errorbar(width = .2) +
  ggtitle("Intervalo de confianÁa da estimativa das medianas do tempo de resposta \ncategorizados por grupo de experimento") +
  labs(x= "Grupos", "Tempo de resposta")


```


--------------------

#(2)

```{r}
grupo.experimento = function(grupo){
  
  data.group = data %>% filter(group==grupo)
  
  experiment = sample_n(data.group, 500, replace = TRUE)

  b = experiment %>% bootstrap(mean(time_diff), R = 500)

  #Media
  mean.boot= bootstrap(experiment, mean(time_diff), R = 500)
  mean.time = CI.bca(mean.boot, c(.025, .975))

  #Mediana
  median.boot = bootstrap(experiment, median(time_diff))
  median.time = CI.percentile(median.boot, probs = c(.025, .975))

  #df <- data.frame(matrix(NA, nrow = 1, ncol = 5))
  #colnames(df) <- c("grupo","limite.inferior.media","limite.superior.media","limite.inferior.mediana","limite.superior.mediana")

  df = data.frame(rbind(mean.time, median.time))

  df$medida = c("media", "mediana")
  df$grupo <- c(grupo, grupo)
  
  colnames(df) <- c("limite.inferior","limite.superior","medida","grupo")

  return(df)
}

#Grupo 1
grupo.1 = grupo.experimento(1)
grupo.2 = grupo.experimento(2)
grupo.3 = grupo.experimento(3)
grupo.4 = grupo.experimento(4)
grupo.5 = grupo.experimento(5)
grupo.6 = grupo.experimento(6)
grupo.7 = grupo.experimento(7)
grupo.8 = grupo.experimento(8)



ic = data.frame(
  rbind(grupo.1,
        grupo.2,
        grupo.3,
        grupo.4,
        grupo.5,
        grupo.6,
        grupo.7,
        grupo.8))


## Para adicionar o label geral

ic %>% 
  ggplot(aes(x = medida, ymin = limite.inferior, ymax = limite.superior)) + 
  geom_errorbar(width = .2) +
  facet_grid(~grupo)+
    ggtitle("Intervalo de confianÁa da estimativa das mÈdias e medianas do tempo de\nresposta categorizados por grupo de experimento")+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```


=======

####Tempo de resposta considerando a sequÍncia de requisiÁıes

Agora iremos analisar o tempo de resposta das requisiÁ„o levando em conta o Ìndice da requisiÁ„o (a primeira requisiÁ„o, segunda, terceira..) 

```{r}
# Mostrar que primeiras requisi√ß√µes s√£o mais r√°pidas que as demais (que d√£o para pegar pelo curr_iteration)

data.first.iterations <- data %>%
  group_by(curr_iteration)

sequencia.instancia = ggplot(data.first.iterations,aes(x=curr_iteration, y=time_diff)) +
  geom_bar(stat = "identity")+
  facet_grid(~n_instances)+
  ggtitle("Tempo de resposta para N˙mero de Inst‚ncias")+
  labs(y = "Tempo de resposta (ms)", x = "Õndice da requisiÁ„o")

grid.draw(label.geral.top(sequencia.instancia,"N˙mero de Inst‚ncias"))

```

--------

###Considera√ß√µes Finais 

O projeto de medi√ß√£o consistiu em uma boa oportunidade de avaliar a escalabilidade do servi√ßo de predi√ß√£o best-trip-recommender antes de ser divulgado para o p√∫blico. Por meio destas medi√ß√µes, pudemos identificar um problema grave: 

* O best-trip-recommender ao receber mais de uma requisi√ß√£o consecutiva, de modo que requisi√ß√£o n + 1 chegue antes da requisi√ß√£o n seja respondida, acumula todas as respostas at√© que a √∫ltima seja executada.

Apesar deste problema, pudemos identificar uma caracter√≠stica bastante satisfat√≥ria: 

* Quando aumentamos o n√∫mero de inst√¢ncias as requisi√ß√µes tendem a ser respondidas mais rapidamente.

 Visto isso, podemos concluir que o sistema medido precisa de ajustes para resolver o problema encontrado, mas ao passo que esse seja resolvido, n√£o parece haver mais empecilhos para que o sistema possa ser consider√°vel escal√°vel. Vale ressaltar que ap√≥s as modifica√ß√µes necess√°rias, seria interessante uma nova medi√ß√£o para averiguar se o sistema se encontra realmente com escalabilidade satisfat√≥ria.

